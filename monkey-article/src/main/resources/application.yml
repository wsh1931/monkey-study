server:
  port: 4100
spring:
  application:
    name: monkey-article
  # ?????
  datasource:
    username: root
    password: "@Uuwusihao1931"
    url: jdbc:mysql://localhost:3306/monkey_blog?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver

  # redis ??
  redis:
    database: 0
    password: wusihao
    host: 192.168.133.138
    port: 6379
    lettuce:
      pool:
        max-active: 8
        max-wait: -1ms
        max-idle: 8
        min-idle: 0
#  # rabbitmq??
#  rabbitmq:
#    host: 192.168.133.138 # rabbitmq ???
#    port: 5672
#    username: wusihao
#    password: wusihao
#    virtual-host: powernode # ????

  # rabbitmq ??
  rabbitmq:
    addresses: 192.168.133.138:5672,192.168.133.134:5672,192.168.133.137:5672
    username: admin
    password: wusihao
    virtual-host: monkey-article # ???
#  # 链路跟踪配置
#  zipkin:
#    base-url: http://localhost:9411
#  sleuth:
#    sampler:
#      probability: 1 #配置采样率  默认的采样比例为: 0.1，即 10%，所设置的值介于 0 到 1 之间，1 则表示全部采集
#      rate: 10 #为了使用速率限制采样器,选择每秒间隔接受的trace量，最小数字为0，最大值为2,147,483,647（最大int） 默认为10。

## eureka集群最终配置
## eureka集群配置
#eureka:
#  client:
#    service-url: # 指定注册地址
#      defaultZone: http://peer1:8761/eureka,http://peer2:8761/eureka,http://peer3:8761/eureka
#    register-with-eureka: true # 注册至eureka-server
#    fetch-registry: true # 应用是否从eureka-server中拉取其他的eureka-client信息到自己
#    registry-fetch-interval-seconds: 10 # 指定拉取时间
#  instance:
#    hostname: localhost # 应用主机名称，最好写ip
#    instance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} # eurekaId
#    prefer-ip-address: true # 显示ip
#    lease-renewal-interval-in-seconds: 10 # 发送心跳时间（续约时间）

  # nacos注册中心配置
  cloud:
    nacos:
      server-addr: localhost:8848 # 向该地址注册
      username: nacos # nacos默认的用户名密码
      password: nacos
      discovery:
        namespace: cd425441-4ee4-4e01-9d42-6c36140e5d0b

ribbon:
  ReadTimeout: 3000 # 设置feign跨服务调用方法的超时时间, 默认为1秒
  ConnectTimeout: 3000 # feign跨微服务方法的连接超时时间

# 设置fegin的日志级别
logging:
  level:
    com:
      monkey:
        monkeyarticle:
          feign: debug

# 开启hystrix功能，默认未开启
feign:
  circuitbreaker:
    enabled: true
hystrix:    #hystrix的全局控制
  command:
    default:    #default是全局控制，也可以换成单个方法控制，把default换成方法名即可
      circuitBreaker: # 当sleepWindowInMilliseconds毫秒内失败次数到达requestVolumeThreshold次或者失败率到达百分之errorThresholdPercentage开启熔断器
        enabled: true   #开启断路器
        requestVolumeThreshold: 3   #失败次数（阀值）  10次
        sleepWindowInMilliseconds: 20000    #窗口时间
        errorThresholdPercentage: 60    #失败率
      execution:
        isolation:
          Strategy: thread  #隔离方式 thread线程隔离集合和semaphore信号量隔离级别
          thread:
            timeoutInMilliseconds: 3000 #调用超时时长
      fallback:
        isolation:
          semaphore:
            maxConcurrentRequests: 1000 #信号量隔离级别最大并发数

#隔离方式 两种隔离方式  thread线程池 按照group（10个线程）划分服务提供者，用户请求的线程和做远程的线程不一样
# 好处 当B服务调用失败了 或者请求B服务的量太大了 不会对C服务造成影响 用户访问比较大的情况下使用比较好  异步的方式
# 缺点 线程间切换开销大，对机器性能影响
# 应用场景 调用第三方服务 并发量大的情况下
# SEMAPHORE信号量隔离 每次请进来 有一个原子计数器 做请求次数的++  当请求完成以后 --
# 好处 对cpu开销小
# 缺点 并发请求不易太多 当请求过多 就会拒绝请求 做一个保护机制
# 场景 使用内部调用 ，并发小的情况下
# 源码入门  HystrixCommand  AbstractCommand HystrixThreadPool
management:
  endpoints:
    web:
      exposure:
        include: '*' # 暴露所有的监控端点
